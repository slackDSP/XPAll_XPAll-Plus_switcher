Disassembly Listing for xpall_switcher
Generated From:
/home/ian/Development/xpall_switcher.X/dist/default/production/xpall_switcher.X.production.elf
Sep 24, 2015 8:50:39 PM

---  /opt/microchip/xc8/v1.34/sources/pic/eeprom.c  -----------------------------------------------------
1:             #include	<htc.h>	
2:             
3:             #if 	EEPROM_SIZE > 0
4:             
5:             void
6:             eecpymem(volatile unsigned char *to, eeprom unsigned char * from, unsigned char size)
06A9  00F4     MOVWF to
7:             {
8:             	volatile unsigned char *cp = to;
06AA  0874     MOVF to, W
06AB  00F2     MOVWF s_mode
06AC  0872     MOVF s_mode, W
06AD  00F3     MOVWF cp
9:             
10:            	while (WR) continue;
06AE  1683     BSF STATUS, 0x5
06AF  1303     BCF STATUS, 0x6
06B0  189C     BTFSC 0x1C, 0x1
06B1  2EAE     GOTO 0x6AE
11:            	EEADR = (unsigned char)from;
06B2  0870     MOVF __pcstackCOMMON, W
06B3  009B     MOVWF 0x1B
12:            	while(size--) {
06B4  3001     MOVLW 0x1
06B5  02F1     SUBWF size, F
06B6  0A71     INCF size, W
06B7  1903     BTFSC STATUS, 0x2
06B8  0008     RETURN
06CE  2EB4     GOTO 0x6B4
13:            		while (WR) continue;
06B9  189C     BTFSC 0x1C, 0x1
06BA  2EB9     GOTO 0x6B9
14:            		#ifdef	__FLASHTYPE
15:            		EECON1 &= 0x7F;
06BB  307F     MOVLW 0x7F
06BC  00F2     MOVWF s_mode
06BD  0872     MOVF s_mode, W
06BE  059C     ANDWF 0x1C, F
16:            		#endif
17:            		RD = 1;
06BF  141C     BSF 0x1C, 0x0
18:            		*cp++ = EEDATA;
06C0  081A     MOVF CMCON1, W
06C1  00F2     MOVWF s_mode
06C2  0873     MOVF cp, W
06C3  0084     MOVWF FSR
06C4  0872     MOVF s_mode, W
06C5  0080     MOVWF INDF
06C6  3001     MOVLW 0x1
06C7  00F2     MOVWF s_mode
06C8  0872     MOVF s_mode, W
06C9  07F3     ADDWF cp, F
19:            		++EEADR;
06CA  3001     MOVLW 0x1
06CB  00F2     MOVWF s_mode
06CC  0872     MOVF s_mode, W
06CD  079B     ADDWF 0x1B, F
20:            	}
21:            }
22:            
23:            void
24:            memcpyee(eeprom unsigned char * to, const unsigned char *from, unsigned char size)
06CF  00F4     MOVWF to
25:            {
26:            	const unsigned char *ptr =from;
06D0  0870     MOVF __pcstackCOMMON, W
06D1  00F2     MOVWF s_mode
06D2  0872     MOVF s_mode, W
06D3  00F3     MOVWF cp
27:            
28:            	while (WR) continue;
06D4  1683     BSF STATUS, 0x5
06D5  1303     BCF STATUS, 0x6
06D6  189C     BTFSC 0x1C, 0x1
06D7  2ED4     GOTO 0x6D4
29:            	EEADR = (unsigned char)to - 1;
06D8  0874     MOVF to, W
06D9  3EFF     ADDLW 0xFF
06DA  009B     MOVWF 0x1B
30:            	#ifdef	__FLASHTYPE
31:            	EECON1 &= 0x7F;
06DB  307F     MOVLW 0x7F
06DC  00F2     MOVWF s_mode
06DD  0872     MOVF s_mode, W
06DE  059C     ANDWF 0x1C, F
32:            	#endif
33:            	while(size--) {
06DF  3001     MOVLW 0x1
06E0  02F1     SUBWF size, F
06E1  0A71     INCF size, W
06E2  1903     BTFSC STATUS, 0x2
06E3  0008     RETURN
0708  2EDF     GOTO 0x6DF
34:            		while (WR) continue;
06E4  1683     BSF STATUS, 0x5
06E5  1303     BCF STATUS, 0x6
06E6  189C     BTFSC 0x1C, 0x1
06E7  2EE4     GOTO 0x6E4
35:            		EEDATA = *ptr++;
06E8  0873     MOVF cp, W
06E9  0084     MOVWF FSR
06EA  0800     MOVF INDF, W
06EB  009A     MOVWF CMCON1
06EC  3001     MOVLW 0x1
06ED  00F2     MOVWF s_mode
06EE  0872     MOVF s_mode, W
06EF  07F3     ADDWF cp, F
36:            		++EEADR;
06F0  3001     MOVLW 0x1
06F1  00F2     MOVWF s_mode
06F2  0872     MOVF s_mode, W
06F3  079B     ADDWF 0x1B, F
37:            		CARRY = 0; if (GIE) CARRY = 1; GIE = 0;
06F4  1283     BCF STATUS, 0x5
06F5  1303     BCF STATUS, 0x6
06F6  1003     BCF STATUS, 0x0
06F7  1B8B     BTFSC INTCON, 0x7
06F8  1403     BSF STATUS, 0x0
06F9  138B     BCF INTCON, 0x7
38:            		WREN = 1;
06FA  1683     BSF STATUS, 0x5
06FB  1303     BCF STATUS, 0x6
06FC  151C     BSF 0x1C, 0x2
39:            		EECON2 = 0x55;
06FD  3055     MOVLW 0x55
06FE  009D     MOVWF 0x1D
40:            		EECON2 = 0xAA;
06FF  30AA     MOVLW 0xAA
0700  009D     MOVWF 0x1D
41:            		WR = 1;
0701  149C     BSF 0x1C, 0x1
42:            		WREN = 0;
0702  111C     BCF 0x1C, 0x2
43:            		if (CARRY) GIE = 1;	//an opportunity for interrupts to happen
0703  1283     BCF STATUS, 0x5
0704  1303     BCF STATUS, 0x6
0705  1C03     BTFSS STATUS, 0x0
0706  2EDF     GOTO 0x6DF
0707  178B     BSF INTCON, 0x7
44:            	}
45:            }
46:            
47:            unsigned char
48:            __eetoc(eeprom void *addr)
068F  00F6     MOVWF addr
49:            {
50:            	unsigned char data;
51:            	eecpymem((unsigned char *) &data,addr,1);
0690  0876     MOVF addr, W
0691  00F5     MOVWF data
0692  0875     MOVF data, W
0693  00F0     MOVWF __pcstackCOMMON
0694  01F1     CLRF size
0695  0AF1     INCF size, F
0696  3077     MOVLW 0x77
0697  26A9     CALL 0x6A9
52:            	return data;
0698  0877     MOVF data, W
53:            }
54:            
55:            unsigned int
56:            __eetoi(eeprom void *addr)
57:            {
58:            	unsigned int data;
59:            	eecpymem((unsigned char *) &data,addr,2);
60:            	return data;
61:            }
62:            
63:            unsigned short long
64:            __eetom(eeprom void *addr)
65:            {
66:            	unsigned short long data;
67:            	eecpymem((unsigned char *) &data,addr,3);
68:            	return data;
69:            }
70:            
71:            unsigned long
72:            __eetol(eeprom void *addr)
73:            {
74:            	unsigned long data;
75:            	eecpymem((unsigned char *) &data,addr,4);
76:            	return data;
77:            }
78:            
79:            unsigned char
80:            __ctoee(eeprom void *addr, unsigned char data)
0685  00F7     MOVWF data
81:            {
82:            	memcpyee(addr,(unsigned char *) &data,1);
0686  3075     MOVLW 0x75
0687  00F6     MOVWF addr
0688  0876     MOVF addr, W
0689  00F0     MOVWF __pcstackCOMMON
068A  01F1     CLRF size
068B  0AF1     INCF size, F
068C  0877     MOVF data, W
068D  26CF     CALL 0x6CF
068E  0008     RETURN
83:            	return data;
84:            }
85:            
86:            unsigned int
87:            __itoee(eeprom void *addr, unsigned int data)
88:            {
89:            	memcpyee(addr,(unsigned char *) &data,2);
90:            	return data;
91:            }
92:            
93:            unsigned short long 
94:            __mtoee(eeprom void *addr, unsigned short long data)
95:            {
96:            	memcpyee(addr,(unsigned char *) &data,3);
97:            	return data;
98:            }
99:            
100:           unsigned long
101:           __ltoee(eeprom void *addr, unsigned long data)
102:           {
103:           	memcpyee(addr,(unsigned char *) &data,4);
104:           	return data;
105:           }
106:           
107:           float
108:           __eetoft(eeprom void *addr)
109:           {
110:           	float data;
111:           	eecpymem((unsigned char *) &data,addr,3);
112:           	return data;
113:           }
114:           
115:           double
116:           __eetofl(eeprom void *addr)
117:           {
118:           	double data;
119:           	eecpymem((unsigned char *) &data,addr,4);
120:           	return data;
121:           }
122:           
123:           float
124:           __fttoee(eeprom void *addr, float data)
125:           {
126:           	memcpyee(addr,(unsigned char *) &data,3);
127:           	return data;
128:           }
129:           
130:           double
131:           __fltoee(eeprom void *addr, double data)
132:           {
133:           	memcpyee(addr,(unsigned char *) &data,4);
134:           	return data;
135:           }
136:           #endif
---  /home/ian/Development/xpall_switcher.X/xpall_switcher_main.c  --------------------------------------
1:             /*XP-All switcher
2:              *Version 2 24/09/2015
3:              *              __________
4:              *       VDD ---|        |--- VSS
5:              *    Switch ---| 12F636 |--- 
6:              *     Reset ---|        |--- 
7:              *           ---|        |--- eeprom 1
8:              *  Blue led ---|        |--- eeprom 2
9:              * Green led ---|        |--- eeprom 3
10:             *   Red led ---|________|--- eeprom 4
11:             *
12:             *
13:             * Copyright © 2015 Ian Maltby
14:             * This work is free. You can redistribute it and/or modify it under the
15:             * terms of the Do What The Fuck You Want To Public License, Version 2,
16:             * as published by Sam Hocevar. See the COPYING file for more details.
17:             */
18:            
19:            #include <xc.h>
20:            #define _XTAL_FREQ 4000000 //clock frequency used by delay macros
21:            #define eeprom1_out RA2
22:            #define switch_in RA5
23:            #define reset_out RA4
24:            #define mode_in RA3
25:            #define eeprom1 0b1110
26:            #define eeprom2 0b1101
27:            #define eeprom3 0b1011
28:            #define eeprom4 0b0111
29:            #define red 0b110
30:            #define green 0b101
31:            #define blue 0b011
32:            #define yellow 0b100
33:            #define xp100 0b0001
34:            #define xp200 0b0110
35:            #define xp300 0b1000
36:            #define xp400 0b1110
37:            
38:            // CONFIG
39:            #pragma config FOSC = INTOSCIO  // Oscillator Selection bits (INTOSCIO oscillator: I/O function on RA4/T1G/OSC2/CLKOUT pin, I/O function on RA5/T1CKI/OSC1/CLKIN)
40:            #pragma config WDTE = OFF       // Watchdog Timer Enable bit (WDT disabled and can be enabled by SWDTEN bit of the WDTCON register)
41:            #pragma config PWRTE = OFF      // Power-up Timer Enable bit (PWRT disabled)
42:            #pragma config MCLRE = OFF      // MCLR pin function select bit (MCLR pin function is alternate function, MCLR function is internally disabled)
43:            #pragma config CP = OFF         // Code Protection bit (Program memory is not code protected)
44:            #pragma config CPD = OFF        // Data Code Protection bit (Data memory is not code protected)
45:            #pragma config BOREN = OFF      // Brown-out Reset Selection bits (BOD and SBODEN disabled)
46:            #pragma config IESO = OFF       // Internal-External Switchover bit (Internal External Switchover mode disabled)
47:            #pragma config FCMEN = OFF      // Fail-Safe Clock Monitor Enable bit (Fail-Safe Clock Monitor disabled)
48:            #pragma config WURE = OFF       // Wake-Up Reset Enable bit (Standard wake-up and continue enabled)
49:            
50:            eeprom char copyright[] = {"XPAll/XPAll+ mode selector Copyright 2015 Ian Maltby"};
51:            eeprom char power_on_mode = 0;
52:            
53:            void set_mode(char s_mode);
54:            
55:            void main() {
56:            
57:                static char pressed = 0;
58:                static char mode = 0;
59:                static char old_mode = 0;
60:                static unsigned int debounce;
61:                static unsigned int timeout;
62:            
63:                CMCON0bits.CM = 7; //Turn off comparator
0765  3007     MOVLW 0x7
0766  1283     BCF STATUS, 0x5
0767  1303     BCF STATUS, 0x6
0768  0499     IORWF CMCON0, F
64:                TRISA = 0; //Set PORTC to output
0769  1683     BSF STATUS, 0x5
076A  1303     BCF STATUS, 0x6
076B  0185     CLRF PORTA
65:                TRISC = 0; //Set PORTA to output
076C  0187     CLRF PORTC
66:                TRISA5 = 1; //Set RA5 to input 
076D  1685     BSF PORTA, 0x5
67:                PORTA = 0; //Clear PORTC set all pins to 0
076E  1283     BCF STATUS, 0x5
076F  1303     BCF STATUS, 0x6
0770  0185     CLRF PORTA
68:                PORTC = 0; //Clear PORTA set all pins to 0
0771  0187     CLRF PORTC
69:            
70:                if (power_on_mode > 3)
0772  3035     MOVLW 0x35
0773  268F     CALL 0x68F
0774  1283     BCF STATUS, 0x5
0775  1303     BCF STATUS, 0x6
0776  00A0     MOVWF __pcstackBANK0
0777  3004     MOVLW 0x4
0778  0220     SUBWF __pcstackBANK0, W
0779  1C03     BTFSS STATUS, 0x0
077A  2F7D     GOTO 0x77D
71:                    mode = 0;
077B  01FA     CLRF mode
077C  2F84     GOTO 0x784
72:                else
73:                    mode = power_on_mode;
077D  3035     MOVLW 0x35
077E  268F     CALL 0x68F
077F  1283     BCF STATUS, 0x5
0780  1303     BCF STATUS, 0x6
0781  00A0     MOVWF __pcstackBANK0
0782  0820     MOVF __pcstackBANK0, W
0783  00FA     MOVWF mode
74:            
75:                set_mode(mode);
0784  087A     MOVF mode, W
0785  2709     CALL 0x709
76:            
77:                __delay_ms(100);
0786  3082     MOVLW 0x82
0787  1283     BCF STATUS, 0x5
0788  1303     BCF STATUS, 0x6
0789  00A1     MOVWF 0x21
078A  30DD     MOVLW 0xDD
078B  00A0     MOVWF __pcstackBANK0
078C  0BA0     DECFSZ __pcstackBANK0, F
078D  2F8C     GOTO 0x78C
078E  0BA1     DECFSZ 0x21, F
078F  2F8C     GOTO 0x78C
0790  2F91     GOTO 0x791
78:            
79:                for (;;) {
80:            
81:                    while (!pressed) {
0791  087C     MOVF pressed, W
0792  1D03     BTFSS STATUS, 0x2
0793  2FE7     GOTO 0x7E7
07E6  2F91     GOTO 0x791
82:                        debounce = (debounce << 1 | switch_in | 57344);
0794  1003     BCF STATUS, 0x0
0795  1283     BCF STATUS, 0x5
0796  1303     BCF STATUS, 0x6
0797  1A85     BTFSC PORTA, 0x5
0798  1403     BSF STATUS, 0x0
0799  3000     MOVLW 0x0
079A  1803     BTFSC STATUS, 0x0
079B  3001     MOVLW 0x1
079C  00A0     MOVWF __pcstackBANK0
079D  01A1     CLRF 0x21
079E  0879     MOVF 0x79, W
079F  00A3     MOVWF 0x23
07A0  0878     MOVF __pbssCOMMON, W
07A1  00A2     MOVWF 0x22
07A2  1003     BCF STATUS, 0x0
07A3  0DA2     RLF 0x22, F
07A4  0DA3     RLF 0x23, F
07A5  0820     MOVF __pcstackBANK0, W
07A6  0422     IORWF 0x22, W
07A7  00A4     MOVWF 0x24
07A8  0821     MOVF 0x21, W
07A9  0423     IORWF 0x23, W
07AA  00A5     MOVWF 0x25
07AB  3000     MOVLW 0x0
07AC  0424     IORWF 0x24, W
07AD  00A6     MOVWF 0x26
07AE  30E0     MOVLW 0xE0
07AF  0425     IORWF 0x25, W
07B0  00A7     MOVWF 0x27
07B1  0826     MOVF 0x26, W
07B2  00F8     MOVWF __pbssCOMMON
07B3  0827     MOVF 0x27, W
07B4  00F9     MOVWF 0x79
83:                        if (debounce == 61440)
07B5  30F0     MOVLW 0xF0
07B6  0679     XORWF 0x79, W
07B7  0478     IORWF __pbssCOMMON, W
07B8  1D03     BTFSS STATUS, 0x2
07B9  2FBC     GOTO 0x7BC
84:                            pressed = 1;
07BA  01FC     CLRF pressed
07BB  0AFC     INCF pressed, F
85:            
86:                        if (debounce == 57344)
07BC  30E0     MOVLW 0xE0
07BD  0679     XORWF 0x79, W
07BE  0478     IORWF __pbssCOMMON, W
07BF  1D03     BTFSS STATUS, 0x2
07C0  2FC8     GOTO 0x7C8
87:                            timeout++;
07C1  3001     MOVLW 0x1
07C2  07A8     ADDWF __pbssBANK0, F
07C3  1803     BTFSC STATUS, 0x0
07C4  0AA9     INCF 0x29, F
07C5  3000     MOVLW 0x0
07C6  07A9     ADDWF 0x29, F
07C7  2FCA     GOTO 0x7CA
88:                        else timeout = 0;
07C8  01A8     CLRF __pbssBANK0
07C9  01A9     CLRF 0x29
89:            
90:                        if (timeout > 9000) {
07CA  3023     MOVLW 0x23
07CB  0229     SUBWF 0x29, W
07CC  3029     MOVLW 0x29
07CD  1903     BTFSC STATUS, 0x2
07CE  0228     SUBWF __pbssBANK0, W
07CF  1C03     BTFSS STATUS, 0x0
07D0  2FE1     GOTO 0x7E1
91:                            mode = old_mode;
07D1  087B     MOVF old_mode, W
07D2  00A0     MOVWF __pcstackBANK0
07D3  0820     MOVF __pcstackBANK0, W
07D4  00FA     MOVWF mode
92:                            power_on_mode = mode;
07D5  087A     MOVF mode, W
07D6  00A0     MOVWF __pcstackBANK0
07D7  0820     MOVF __pcstackBANK0, W
07D8  00F5     MOVWF data
07D9  3035     MOVLW 0x35
07DA  2685     CALL 0x685
93:                            set_mode(mode);
07DB  087A     MOVF mode, W
07DC  2709     CALL 0x709
94:                            timeout = 0;
07DD  1283     BCF STATUS, 0x5
07DE  1303     BCF STATUS, 0x6
07DF  01A8     CLRF __pbssBANK0
07E0  01A9     CLRF 0x29
95:            
96:                        }
97:            
98:                        __delay_us(200);
07E1  3042     MOVLW 0x42
07E2  00A0     MOVWF __pcstackBANK0
07E3  0BA0     DECFSZ __pcstackBANK0, F
07E4  2FE3     GOTO 0x7E3
07E5  0000     NOP
99:                    }
100:           
101:                   pressed = 0;
07E7  01FC     CLRF pressed
102:                   old_mode = mode;
07E8  087A     MOVF mode, W
07E9  1283     BCF STATUS, 0x5
07EA  1303     BCF STATUS, 0x6
07EB  00A0     MOVWF __pcstackBANK0
07EC  0820     MOVF __pcstackBANK0, W
07ED  00FB     MOVWF old_mode
103:                   mode = (mode + 1) & 3;
07EE  087A     MOVF mode, W
07EF  3E01     ADDLW 0x1
07F0  3903     ANDLW 0x3
07F1  00A0     MOVWF __pcstackBANK0
07F2  0820     MOVF __pcstackBANK0, W
07F3  00FA     MOVWF mode
104:           
105:                   set_mode(mode);
07F4  087A     MOVF mode, W
07F5  2709     CALL 0x709
106:           
107:               }
07F6  2F91     GOTO 0x791
108:           }
109:           
110:           void set_mode(char s_mode) {
0709  00F2     MOVWF s_mode
111:           
112:               const char eeprom_select[4] = {eeprom1, eeprom2, eeprom3, eeprom4};
113:               const char led_select[4] = {red, green, yellow, blue};
114:               const char mode_select[4] = {xp100, xp200, xp300, xp400};
115:           
116:               if (mode_in == 1) {
070A  1283     BCF STATUS, 0x5
070B  1303     BCF STATUS, 0x6
070C  1D85     BTFSS PORTA, 0x3
070D  2F2B     GOTO 0x72B
117:                   eeprom1_out = mode_select[s_mode] & 1;
070E  0872     MOVF s_mode, W
070F  3E09     ADDLW 0x9
0710  0084     MOVWF FSR
0711  2001     CALL 0x1
0712  00F0     MOVWF __pcstackCOMMON
0713  0C70     RRF __pcstackCOMMON, W
0714  1C03     BTFSS STATUS, 0x0
0715  2F1A     GOTO 0x71A
0716  1283     BCF STATUS, 0x5
0717  1303     BCF STATUS, 0x6
0718  1505     BSF PORTA, 0x2
0719  2F1D     GOTO 0x71D
071A  1283     BCF STATUS, 0x5
071B  1303     BCF STATUS, 0x6
071C  1105     BCF PORTA, 0x2
118:                   PORTC = (mode_select[s_mode] >> 1) | (led_select[s_mode] << 3);
071D  0872     MOVF s_mode, W
071E  3E05     ADDLW 0x5
071F  0084     MOVWF FSR
0720  2001     CALL 0x1
0721  00F0     MOVWF __pcstackCOMMON
0722  3003     MOVLW 0x3
0723  1003     BCF STATUS, 0x0
0724  0DF0     RLF __pcstackCOMMON, F
0725  3EFF     ADDLW 0xFF
0726  1D03     BTFSS STATUS, 0x2
0727  2F23     GOTO 0x723
0728  0872     MOVF s_mode, W
0729  3E09     ADDLW 0x9
072A  2F47     GOTO 0x747
119:               } else {
120:                   eeprom1_out = eeprom_select[s_mode] & 1;
072B  0872     MOVF s_mode, W
072C  3E01     ADDLW 0x1
072D  0084     MOVWF FSR
072E  2001     CALL 0x1
072F  00F0     MOVWF __pcstackCOMMON
0730  0C70     RRF __pcstackCOMMON, W
0731  1C03     BTFSS STATUS, 0x0
0732  2F37     GOTO 0x737
0733  1283     BCF STATUS, 0x5
0734  1303     BCF STATUS, 0x6
0735  1505     BSF PORTA, 0x2
0736  2F3A     GOTO 0x73A
0737  1283     BCF STATUS, 0x5
0738  1303     BCF STATUS, 0x6
0739  1105     BCF PORTA, 0x2
121:                   PORTC = (eeprom_select[s_mode] >> 1) | (led_select[s_mode] << 3);
073A  0872     MOVF s_mode, W
073B  3E05     ADDLW 0x5
073C  0084     MOVWF FSR
073D  2001     CALL 0x1
073E  00F0     MOVWF __pcstackCOMMON
073F  3003     MOVLW 0x3
0740  1003     BCF STATUS, 0x0
0741  0DF0     RLF __pcstackCOMMON, F
0742  3EFF     ADDLW 0xFF
0743  1D03     BTFSS STATUS, 0x2
0744  2F40     GOTO 0x740
0745  0872     MOVF s_mode, W
0746  3E01     ADDLW 0x1
0747  0084     MOVWF FSR
0748  2001     CALL 0x1
0749  00F1     MOVWF size
074A  1003     BCF STATUS, 0x0
074B  0C71     RRF size, W
074C  0470     IORWF __pcstackCOMMON, W
074D  0087     MOVWF PORTC
122:               }
123:           
124:               __delay_ms(5);
074E  3007     MOVLW 0x7
074F  00F1     MOVWF size
0750  307D     MOVLW 0x7D
0751  00F0     MOVWF __pcstackCOMMON
0752  0BF0     DECFSZ __pcstackCOMMON, F
0753  2F52     GOTO 0x752
0754  0BF1     DECFSZ size, F
0755  2F52     GOTO 0x752
125:               reset_out = 0;
0756  1283     BCF STATUS, 0x5
0757  1303     BCF STATUS, 0x6
0758  1205     BCF PORTA, 0x4
126:               __delay_ms(5);
0759  3007     MOVLW 0x7
075A  00F1     MOVWF size
075B  307D     MOVLW 0x7D
075C  00F0     MOVWF __pcstackCOMMON
075D  0BF0     DECFSZ __pcstackCOMMON, F
075E  2F5D     GOTO 0x75D
075F  0BF1     DECFSZ size, F
0760  2F5D     GOTO 0x75D
127:               reset_out = 1;
0761  1283     BCF STATUS, 0x5
0762  1303     BCF STATUS, 0x6
0763  1605     BSF PORTA, 0x4
128:           
129:           }
0764  0008     RETURN
130:           
131:           
